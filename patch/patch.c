#define _GNU_SOURCE 1
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <getopt.h>
#include <signal.h>
#include <errno.h>
#include <string.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <linux/limits.h>

#include <elf.h>

extern const char *__progname;

int
strnhexcmp(const char *hexadecimal, const unsigned char *buffer, size_t sz)
{
    for (size_t i = 0; i < sz; i++) {
        int ret;
        char byte[3];
        if (hexadecimal[sz*2] == '\0' ||
            hexadecimal[sz*2+1] == '\0') return -1;
        sprintf(byte, "%hhx", buffer[i]);
        ret = strcasecmp(byte, hexadecimal + sz*2);
        if (!ret) return ret;
    }
    return 0;
}

static void
usage(void)
{
    fprintf(stderr, "[?] Usage: %s", __progname);
    fprintf(stderr, "[?] Patching CVE-2015-3456 on a running instance of QEMU\n");
    fprintf(stderr, "[?] \n");
    fprintf(stderr, "[?]  -h, --help                 display help and exit\n");
    fprintf(stderr, "[?]  -p, --pid                  PID of the QEMU process to patch\n");
    fprintf(stderr, "[?] \n");
    fprintf(stderr, "[?] Run without any parameter to get step-by-step help.\n");
}

#if __WORDSIZE == 32
typedef uint32_t uword_t;
#elif __WORDSIZE == 64
typedef uint64_t uword_t;
#endif

/* Read memory of the given process */
static void *
ptrace_read(pid_t pid, void *address, size_t size)
{
    /* Allocate the buffer */
    uword_t *buffer = malloc((size/sizeof(uword_t) + 1)*sizeof(uword_t));
    if (!buffer) return NULL;

    /* Read word by word */
    size_t readsz = 0;
    do {
        errno = 0;
        if ((buffer[readsz/sizeof(uword_t)] = ptrace(PTRACE_PEEKTEXT, pid,
                                                     (unsigned char*)address + readsz,
                                                     0)) && errno) {
            fprintf(stderr, "[!] Unable to peek one word at address %p: %m\n",
                    (unsigned char *)address + readsz);
            free(buffer);
            return NULL;
        }
        readsz += sizeof(uword_t);
    } while (readsz < size);
    return (unsigned char *)buffer;
}

/* Attach to the running process */
static int
patch_attach(pid_t pid)
{
    int status;

    /* First step is to attach to the processus. Important effects of
     * such an attachment is that we will hijack all signals received
     * by the processus (except SIGKILL). PTRACE_SEIZE would be a
     * better option but it is only available from Linux 3.4. */
    printf("[.] Attaching to PID %d...\n", pid);
    if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) == -1) {
        fprintf(stderr, "[!] Unable to attach to PID %d: %m\n", pid);
        return -1;
    }

try_again:
    /* Wait the child to be stopped to be able to read its memory */
    do {
        if (waitpid(pid, &status, 0) == -1) {
            fprintf(stderr, "[!] Error while attaching to PID %d: %m\n", pid);
            return -1;
        }
        if (WIFEXITED(status)) {
            fprintf(stderr, "[!] PID %d just died with status code %d\n",
                    pid, WEXITSTATUS(status));
            return -1;
        }
        if (WIFSIGNALED(status)) {
            fprintf(stderr, "[!] PID %d just stopped with signal %d\n",
                    pid, WTERMSIG(status));
            return -1;
        }
    } while (!WIFSTOPPED(status));

    /* The child is stopped, but we need to check this is because of
     * SIGSTOP we just sent (and not deliver it). Other signals should
     * be delivered. */
    siginfo_t si;
    if (ptrace(PTRACE_GETSIGINFO, pid, NULL, &si) == -1) {
        fprintf(stderr, "[!] Unable to read siginfo for PID %d: %m\n", pid);
        return -1;
    }

    if (si.si_signo != SIGSTOP) {
        /* Not the signal we are expecting, retransmit it to
         * the original process. */
        fprintf(stderr, "[!] Received a spurious signal (%d)\n", si.si_signo);
        if (ptrace(PTRACE_CONT, pid, NULL,
                   (void *)(unsigned long)si.si_signo)) {
            fprintf(stderr, "[!] Unable to retransmit the signal to PID %d: %m\n",
                    pid);
            return -1;
        }
        goto try_again;
    }

    printf("[*] Successfully attached to PID %d\n", pid);
    return 0;
}

/* Get the base address */
static int
patch_base_address(pid_t pid, void **base)
{
    int result = -1;
    char *proc_exe = NULL;
    char *proc_maps = NULL;
    FILE *pmaps = NULL;
    *base = NULL;

    /* First, we need the executable name. We use /proc/PID/exe for
     * that. */
    if (asprintf(&proc_exe, "/proc/%d/exe", pid) == -1) {
        fprintf(stderr, "[!] No memory for path to /proc/%d/exe: %m\n", pid);
        goto out;
    }

    char linkname[PATH_MAX + 1];
    if (readlink(proc_exe, linkname, PATH_MAX + 1) == -1) {
        fprintf(stderr, "[!] Unable to get link destination for /proc/%d/exe: %m\n", pid);
        goto out;
    }
    printf("[*] Executable name is %s\n", linkname);

    /* Then, we parse /proc/PID/maps to get the base address. The base
     * address is the first line matching our executable name. With
     * PIE, this may not be the first line at all. */
    if (asprintf(&proc_maps, "/proc/%d/maps", pid) == -1) {
        fprintf(stderr, "[!] No memory for path to /proc/%d/maps: %m\n", pid);
        goto out;
    }
    if ((pmaps = fopen(proc_maps, "r")) == NULL) {
        fprintf(stderr, "[!] Unable to open /proc/%d/maps for reading: %m\n", pid);
        goto out;
    }
    int ret, found = 0;
    long long startaddr, endaddr, offset, inode;
    unsigned char major, minor;
    char permissions[5];
    char pathname[256] = {};
    while (ret = fscanf(pmaps, "%16llx-%16llx %4s %16llx %2hhx:%2hhx %16llx",
                        &startaddr, &endaddr, permissions, &offset,
                        &major, &minor, &inode),
           ret != 0 && ret != EOF) {
        if (ret > 0 && inode != 0) {
            if (fscanf(pmaps, " %255[^\n]\n",
                       pathname) != 0) {
                if (!strcmp(pathname, linkname)) {
                    printf("[*] Base address is 0x%llx\n", startaddr);
                    found = 1;
                    break;
                }
            }
        }
    }
    if (!found) {
        fprintf(stderr, "[!] Unable to found base address in /proc/%d/maps\n", pid);
        goto out;
    }
    if (strcmp(permissions, "r-xp")) {
        fprintf(stderr, "[!] Base address is expected to be read/execute but is %s\n",
                permissions);
        goto out;
    }

    *base = (void*)startaddr;
    result = 0;

out:
    if (pmaps) fclose(pmaps);
    free(proc_exe);
    return result;
}

/* Do some sanity checks before patching the process. */
static int
patch_sanity_checks(pid_t pid, void *base, const char *build_id)
{
    int ret = -1;
    void *elf_magic = NULL;
    char *strings = NULL;
    Elf64_Ehdr *elf_header = NULL;
    Elf64_Shdr *elf_sections = NULL;
    Elf64_Nhdr *note = NULL;
    
    /* Do we have an ELF header at the given base address? */
    static unsigned char expected_elf_magic[] = { 0x7f, 'E', 'L', 'F' };
    elf_magic = ptrace_read(pid, base, sizeof(expected_elf_magic) + 1);
    if (elf_magic == NULL ||
        memcmp(expected_elf_magic, elf_magic, sizeof(expected_elf_magic))) {
        fprintf(stderr, "[!] ELF magic header not found\n");
        goto out;
    }

    /* Now, we will try to read the GNU build ID. First, read the ELF
     * header. */
    if (((unsigned char *)elf_magic)[sizeof(expected_elf_magic)] != ELFCLASS64) {
        fprintf(stderr, "[!] Sorry, only 64bit executable are handled for now\n");
        goto out;
    }
    elf_header = ptrace_read(pid, base, sizeof(Elf64_Ehdr));
    if (elf_header == NULL) {
        fprintf(stderr, "[!] Unable to read ELF header\n");
        goto out;
    }

    /* We need to read the section headers */
    elf_sections = ptrace_read(pid,
                               (char*)base + elf_header->e_shoff,
                               elf_header->e_shentsize * elf_header->e_shnum);
    if (elf_sections == NULL) {
        fprintf(stderr, "[!] Unable to read ELF sections\n");
        goto out;
    }
    /* We need the string table */
    if (elf_header->e_shstrndx == SHN_UNDEF) {
        fprintf(stderr, "[!] No section string table\n");
        goto out;
    }
    strings = ptrace_read(pid,
                          (char *)base + elf_sections[elf_header->e_shstrndx].sh_offset,
                          elf_sections[elf_header->e_shstrndx].sh_size);
    if (strings == NULL) {
        fprintf(stderr, "[!] Unable to read section string table\n");
        goto out;
    }
    for (size_t i = 0; i < elf_header->e_shnum; i++) {
        if (elf_sections[i].sh_type == SHT_NOTE &&
            !strcmp(&strings[elf_sections[i].sh_name],
                    ".note.gnu.build-id")) {
            /* Read the build ID */
            note = ptrace_read(pid,
                                           (char *)base + elf_sections[i].sh_offset,
                                           elf_sections[i].sh_size);
            if (note == NULL) {
                fprintf(stderr, "[!] Unable to read build ID\n");
                goto out;
            }
            if (strnhexcmp(build_id, (unsigned char *)(note + 1), note->n_namesz)) {
                fprintf(stderr, "[!] Build ID is not the same\n");
                goto out;
            }
            ret = 0;
            printf("[*] Build ID match\n");
            goto out;
        }
    }
    fprintf(stderr, "[!] Build ID not found\n");

out:
    free(elf_magic);
    free(elf_sections);
    free(elf_header);
    free(strings);
    free(note);
    return ret;
}

int
main(int argc, char **argv)
{
    pid_t pid = 0;
    const char *build_id = NULL;

    static struct option long_options[] = {
        { "help",     no_argument,       0, 'h' },
        { "pid",      required_argument, 0, 'p' },
        { "build-id", required_argument, 0, 'b' },
        { 0 }
    };

    while (1) {
        int option_index = 0, c;
        c = getopt_long(argc, argv, "hp:b:",
                        long_options, &option_index);
        if (c == -1) break;

        switch (c) {
        case 'h':
            usage();
            return EXIT_SUCCESS;
        case 'p':
            pid = atoi(optarg);
            break;
        case 'b':
            build_id = optarg;
            break;
        default:
            fprintf(stderr, "[!] Unknown option `%c'\n", c);
            usage();
            return EXIT_FAILURE;
        }
    }
    if (optind < argc) {
        fprintf(stderr, "[!] Positional arguments are not accepted\n");
        usage();
        return EXIT_FAILURE;
    }

    /* Check we have everything we need */
    if (!pid) {
        fprintf(stderr, "[!] A PID is mandatory, use --pid to provide one\n");
        return EXIT_FAILURE;
    }
    if (!build_id) {
        fprintf(stderr, "[!] A build ID is mandatory, use --build-id to provide one.\n");
        fprintf(stderr, "[.] Use `readelf -n` to find it. It is a safety check.\n");
        return EXIT_FAILURE;
    }

    void *base;                 /* base address */
    if (0 ||
        patch_attach(pid) == -1 ||
        patch_base_address(pid, &base) == -1 ||
        patch_sanity_checks(pid, base, build_id) == -1 ||
        0) return EXIT_FAILURE;
    return EXIT_SUCCESS;
}
