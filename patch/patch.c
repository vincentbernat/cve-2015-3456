#define _GNU_SOURCE 1
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <getopt.h>
#include <signal.h>
#include <errno.h>
#include <string.h>
#include <limits.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <linux/limits.h>

#include <elf.h>

extern const char *__progname;

#define QEMU_NOT_IMPLEMENTED_HANDLER 0x1f
#define QEMU_COMMAND_TO_HANDLER_SIZE (1 << 8)
#define QEMU_UNIMPLEMENTED_COMMANDS  170
/* The above could is a safety check. It can be retrieved with gdb:

    (gdb) set $i=0
    (gdb) set $unimplemented=0
    (gdb) while ($i < 256)
     >if (command_to_handler[$i++] == 0x1f)
      >set variable $unimplemented = $unimplemented + 1
      >end
     >end
    (gdb) print $unimplemented
    $1 = 170

*/

int
strnhexcmp(const char *hexadecimal, const unsigned char *buffer, size_t sz)
{
    for (size_t i = 0; i < sz; i++) {
        int ret;
        char byte[3];
        if (hexadecimal[i*2] == '\0' ||
            hexadecimal[i*2+1] == '\0') return -1;
        sprintf(byte, "%hhx", buffer[i]);
        ret = strcasecmp(byte, hexadecimal + i*2);
        if (!ret) return ret;
    }
    return 0;
}

int
fuzzy_strcmp(const char *pathname, char *fuzzy)
{
    if (!strcmp(pathname, fuzzy)) return 0;

    /* We have to handle the case where the file is present on a
     * sublayer. In this case, (deleted) may not appear in
     * pathname. */
    char *nfuzzy = strdup(fuzzy), *p;
    if (!strstr(pathname, " (deleted)") &&
        (p = strstr(nfuzzy, " (deleted)"))) {
        p[0] = '\0';
        if (!strcmp(pathname, nfuzzy)) {
            free(nfuzzy);
            return 0;
        }
    }

    /* Another possibility is to have a prefix before pathname */
    if ((p = strstr(pathname, nfuzzy))) {
        if (!strcmp(p, nfuzzy)) {
            free(nfuzzy);
            return 0;
        }
    }
    free(nfuzzy);
    return -1;
}

static void
usage(void)
{
    fprintf(stderr, "[?] Usage: %s", __progname);
    fprintf(stderr, "[?] Patching CVE-2015-3456 on a running instance of QEMU\n");
    fprintf(stderr, "[?] \n");
    fprintf(stderr, "[?]  -h, --help                 display help and exit\n");
    fprintf(stderr, "[?]  -p, --pid                  PID of the QEMU process to patch\n");
    fprintf(stderr, "[?]  -b, --build-id             Build ID of the running QEMU process\n");
    fprintf(stderr, "[?]  -o, --offset               `command_to_handler` offset\n");
    fprintf(stderr, "[?] \n");
    fprintf(stderr, "[?] Run without any parameter to get step-by-step help.\n");
}

#if __WORDSIZE == 32
typedef uint32_t uword_t;
#elif __WORDSIZE == 64
typedef uint64_t uword_t;
#endif

#define	align_power(addr, align)	\
  (((addr) + ((uword_t) 1 << (align)) - 1) & ((uword_t) -1 << (align)))

/* Read memory of the given process */
static void *
ptrace_read(pid_t pid, void *address, size_t size)
{
    /* Allocate the buffer */
    uword_t *buffer = malloc((size/sizeof(uword_t) + 1)*sizeof(uword_t));
    if (!buffer) return NULL;

    /* Read word by word */
    size_t readsz = 0;
    do {
        errno = 0;
        if ((buffer[readsz/sizeof(uword_t)] = ptrace(PTRACE_PEEKTEXT, pid,
                                                     (unsigned char*)address + readsz,
                                                     0)) && errno) {
            fprintf(stderr, "[!] Unable to peek one word at address %p: %m\n",
                    (unsigned char *)address + readsz);
            free(buffer);
            return NULL;
        }
        readsz += sizeof(uword_t);
    } while (readsz < size);
    return (unsigned char *)buffer;
}

/* Write memory of the given process. Alignment is needed. */
static int
ptrace_write(pid_t pid, void *destination, void *source, size_t size)
{
    uword_t *buffer = source;

    /* Write word by word */
    size_t writesz = 0;
    do {
        long val = *buffer;
        if (ptrace(PTRACE_POKETEXT, pid,
                   (unsigned char*)destination + writesz,
                   val) == -1) {
            fprintf(stderr, "[!] Unable to poke one word at address %p: %m\n",
                    (unsigned char *)destination + writesz);
            return -1;
        }
        writesz += sizeof(uword_t);
        buffer++;
    } while (writesz < size);
    return 0;
}

/* Attach to the running process */
static int
patch_attach(pid_t pid)
{
    int status;

    /* First step is to attach to the processus. Important effects of
     * such an attachment is that we will hijack all signals received
     * by the processus (except SIGKILL). PTRACE_SEIZE would be a
     * better option but it is only available from Linux 3.4. */
    printf("[.] Attaching to PID %d...\n", pid);
    if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) == -1) {
        fprintf(stderr, "[!] Unable to attach to PID %d: %m\n", pid);
        return -1;
    }

try_again:
    /* Wait the child to be stopped to be able to read its memory */
    do {
        if (waitpid(pid, &status, 0) == -1) {
            fprintf(stderr, "[!] Error while attaching to PID %d: %m\n", pid);
            return -1;
        }
        if (WIFEXITED(status)) {
            fprintf(stderr, "[!] PID %d just died with status code %d\n",
                    pid, WEXITSTATUS(status));
            return -1;
        }
        if (WIFSIGNALED(status)) {
            fprintf(stderr, "[!] PID %d just stopped with signal %d\n",
                    pid, WTERMSIG(status));
            return -1;
        }
    } while (!WIFSTOPPED(status));

    /* The child is stopped, but we need to check this is because of
     * SIGSTOP we just sent (and not deliver it). Other signals should
     * be delivered. */
    siginfo_t si;
    if (ptrace(PTRACE_GETSIGINFO, pid, NULL, &si) == -1) {
        fprintf(stderr, "[!] Unable to read siginfo for PID %d: %m\n", pid);
        return -1;
    }

    if (si.si_signo != SIGSTOP) {
        /* Not the signal we are expecting, retransmit it to
         * the original process. */
        fprintf(stderr, "[!] Received a spurious signal (%d)\n", si.si_signo);
        if (ptrace(PTRACE_CONT, pid, NULL,
                   (void *)(unsigned long)si.si_signo)) {
            fprintf(stderr, "[!] Unable to retransmit the signal to PID %d: %m\n",
                    pid);
            return -1;
        }
        goto try_again;
    }

    printf("[*] Successfully attached to PID %d\n", pid);
    return 0;
}

/* Get the base address */
static int
patch_base_address(pid_t pid, void **base)
{
    int result = -1;
    char *proc_exe = NULL;
    char *proc_maps = NULL;
    FILE *pmaps = NULL;
    *base = NULL;

    /* First, we need the executable name. We use /proc/PID/exe for
     * that. */
    if (asprintf(&proc_exe, "/proc/%d/exe", pid) == -1) {
        fprintf(stderr, "[!] No memory for path to /proc/%d/exe: %m\n", pid);
        goto out;
    }

    char linkname[PATH_MAX + 1];
    if (readlink(proc_exe, linkname, PATH_MAX + 1) == -1) {
        fprintf(stderr, "[!] Unable to get link destination for /proc/%d/exe: %m\n", pid);
        goto out;
    }
    printf("[*] Executable name is %s\n", linkname);

    /* Then, we parse /proc/PID/maps to get the base address. The base
     * address is the first line matching our executable name. With
     * PIE, this may not be the first line at all. */
    if (asprintf(&proc_maps, "/proc/%d/maps", pid) == -1) {
        fprintf(stderr, "[!] No memory for path to /proc/%d/maps: %m\n", pid);
        goto out;
    }
    if ((pmaps = fopen(proc_maps, "r")) == NULL) {
        fprintf(stderr, "[!] Unable to open /proc/%d/maps for reading: %m\n", pid);
        goto out;
    }
    int ret, found = 0;
    long long startaddr, endaddr, offset, inode;
    unsigned char major, minor;
    char permissions[5];
    char pathname[256] = {};
    while (ret = fscanf(pmaps, "%16llx-%16llx %4s %16llx %2hhx:%2hhx %16llx",
                        &startaddr, &endaddr, permissions, &offset,
                        &major, &minor, &inode),
           ret != 0 && ret != EOF) {
        if (ret > 0 && inode != 0) {
            if (fscanf(pmaps, " %255[^\n]\n",
                       pathname) != 0) {
                if (!fuzzy_strcmp(pathname, linkname)) {
                    printf("[*] Base address is 0x%llx\n", startaddr);
                    found = 1;
                    break;
                }
            }
        }
    }
    if (!found) {
        fprintf(stderr, "[!] Unable to found base address in /proc/%d/maps\n", pid);
        goto out;
    }
    if (strcmp(permissions, "r-xp")) {
        fprintf(stderr, "[!] Base address is expected to be read/execute but is %s\n",
                permissions);
        goto out;
    }

    *base = (void*)startaddr;
    result = 0;

out:
    if (pmaps) fclose(pmaps);
    free(proc_exe);
    return result;
}

/* Do some sanity checks before patching the process. */
static int
patch_sanity_checks(pid_t pid, void *base, int *type, const char *build_id)
{
    int ret = -1;
    void *elf_magic = NULL;
    Elf64_Ehdr *elf_header = NULL;
    Elf64_Phdr *elf_programs = NULL;
    Elf64_Nhdr *note = NULL;

    /* Do we have an ELF header at the given base address? */
    static unsigned char expected_elf_magic[] = { 0x7f, 'E', 'L', 'F' };
    elf_magic = ptrace_read(pid, base, sizeof(expected_elf_magic) + 1);
    if (elf_magic == NULL ||
        memcmp(expected_elf_magic, elf_magic, sizeof(expected_elf_magic))) {
        fprintf(stderr, "[!] ELF magic header not found\n");
        goto out;
    }

    /* Now, we will try to read the GNU build ID. First, read the ELF
     * header. */
    if (((unsigned char *)elf_magic)[sizeof(expected_elf_magic)] != ELFCLASS64) {
        fprintf(stderr, "[!] Sorry, only 64bit executable are handled for now\n");
        goto out;
    }
    elf_header = ptrace_read(pid, base, sizeof(Elf64_Ehdr));
    if (elf_header == NULL) {
        fprintf(stderr, "[!] Unable to read ELF header\n");
        goto out;
    }

    /* Save the type, we need it to interpret the symbol offset later. */
    if (elf_header->e_type != ET_DYN &&
        elf_header->e_type != ET_EXEC) {
        fprintf(stderr, "[!] ELF header says we are not an executable\n");
        goto out;
    }
    *type = elf_header->e_type;

    /* We need to read the program headers (the section headers are
     * not here anymore most of the time) */
    elf_programs = ptrace_read(pid,
                               (char*)base + elf_header->e_phoff,
                               elf_header->e_phentsize * elf_header->e_phnum);
    if (elf_programs == NULL) {
        fprintf(stderr, "[!] Unable to read ELF sections\n");
        goto out;
    }
    for (size_t i = 0; i < elf_header->e_phnum; i++) {
        if (elf_programs[i].p_type == PT_NOTE) {
            note = ptrace_read(pid,
                               (char *)base + elf_programs[i].p_offset,
                               elf_programs[i].p_filesz);
            if (note == NULL) {
                fprintf(stderr, "[!] Unable to read note %zu\n", i);
                continue;
            }
            Elf64_Nhdr *current_note = note;
            while ((Elf64_Xword)((unsigned char*)current_note -
                                 (unsigned char*)note) < elf_programs[i].p_filesz) {
                if (current_note->n_type == NT_GNU_BUILD_ID &&
                    !strncmp("GNU", (const char *)(current_note + 1),
                             current_note->n_namesz)) {
                    if (strnhexcmp(build_id,
                                   (unsigned char *)(current_note + 1) +
                                   align_power(current_note->n_namesz, 2),
                                   current_note->n_descsz)) {
                        fprintf(stderr, "[!] Build ID is not the same\n");
                        goto out;
                    }
                    ret = 0;
                    printf("[*] Build ID match\n");
                    goto out;
                }
                current_note = (Elf64_Nhdr*)((unsigned char *)(current_note + 1) +
                                             align_power(current_note->n_namesz, 2) +
                                             align_power(current_note->n_descsz, 2));
            }
        }
        free(note); note = NULL;
    }
    fprintf(stderr, "[!] Build ID not found\n");

out:
    free(elf_magic);
    free(elf_programs);
    free(elf_header);
    free(note);
    return ret;
}

/* Do the modification */
static int
patch_doit(pid_t pid, void *base, int type, off_t offset)
{
    int ret = -1;
    unsigned char *command_to_handler = NULL;
    unsigned char *target = ((type == ET_EXEC)?(unsigned char*)0:(unsigned char*)base) + offset;

    /* Get the table */
    printf("[.] Retrieving command_to_handler table...\n");
    command_to_handler = ptrace_read(pid,
                                     target,
                                     QEMU_COMMAND_TO_HANDLER_SIZE);
    if (command_to_handler == NULL) {
        fprintf(stderr, "[!] Unable to read command_to_handler table at offset 0x%jx: %m\n",
                (intmax_t)offset);
        goto out;
    }
    size_t i, unimplemented = 0;
    for (i = 0; i < QEMU_COMMAND_TO_HANDLER_SIZE; i++) {
        if (command_to_handler[i] == QEMU_NOT_IMPLEMENTED_HANDLER)
            unimplemented++;
    }
    if (unimplemented == QEMU_COMMAND_TO_HANDLER_SIZE) {
        printf("[*] Table already patched. Do nothing\n");
        ret = 0;
        goto out;
    }
    if (unimplemented != QEMU_UNIMPLEMENTED_COMMANDS) {
        fprintf(stderr,
                "[!] Mismatch between expected number of unimplemented commands (%d) and actual value (%zu)\n",
                QEMU_UNIMPLEMENTED_COMMANDS, unimplemented);
        fprintf(stderr, "[.]\n");
        fprintf(stderr, "[.] This can be fixed directly in the source code.\n");
        goto out;
    }

    /* Patch it */
    printf("[.] Patching QEMU...\n");
    for (i = 0; i < QEMU_COMMAND_TO_HANDLER_SIZE; i++) {
        command_to_handler[i] = QEMU_NOT_IMPLEMENTED_HANDLER;
    }
    if (ptrace_write(pid, target, command_to_handler, QEMU_COMMAND_TO_HANDLER_SIZE) == -1) {
        fprintf(stderr, "[!] Unable to patch command_to_handler table: %m\n");
        goto out;
    }
    printf("[*] QEMU successfully patched!\n");
    ret = 0;

out:
    free(command_to_handler);
    return ret;
}

int
main(int argc, char **argv)
{
    pid_t pid = 0;
    off_t offset = 0;
    const char *build_id = NULL;

    static struct option long_options[] = {
        { "help",     no_argument,       0, 'h' },
        { "pid",      required_argument, 0, 'p' },
        { "build-id", required_argument, 0, 'b' },
        { "offset",   required_argument, 0, 'o' },
        { 0 }
    };

    while (1) {
        int option_index = 0, c;
        char *end;
        c = getopt_long(argc, argv, "hp:b:o:",
                        long_options, &option_index);
        if (c == -1) break;

        switch (c) {
        case 'h':
            usage();
            return EXIT_SUCCESS;
        case 'p':
            pid = atoi(optarg);
            break;
        case 'b':
            build_id = optarg;
            break;
        case 'o':
            offset = strtoll(optarg, &end, 16);
            if ((errno == ERANGE && (offset == LONG_MAX ||
                                     offset == LONG_MIN)) ||
                (errno != 0 && offset == 0)) {
                fprintf(stderr, "[!] Invalid offset provided\n");
                return EXIT_FAILURE;
            }
            break;
        default:
            fprintf(stderr, "[!] Unknown option `%c'\n", c);
            usage();
            return EXIT_FAILURE;
        }
    }
    if (optind < argc) {
        fprintf(stderr, "[!] Positional arguments are not accepted\n");
        usage();
        return EXIT_FAILURE;
    }

    /* Check we have everything we need */
    if (!pid) {
        fprintf(stderr, "[!] A PID is mandatory, use `--pid` to provide one\n");
        return EXIT_FAILURE;
    }
    if (!build_id) {
        fprintf(stderr, "[!] A build ID is mandatory, use `--build-id` to provide one.\n");
        fprintf(stderr, "[.]\n");
        fprintf(stderr, "[.] Use `readelf -n` to find it. It is a safety check.\n");
        fprintf(stderr, "[.] You should get something like this:\n");
        fprintf(stderr, "[.]\n");
        fprintf(stderr, "[.] Displaying notes found at file offset 0x00000274 with length 0x00000024:\n");
        fprintf(stderr, "[.]   Owner                 Data size       Description\n");
        fprintf(stderr, "[.]   GNU                  0x00000014       NT_GNU_BUILD_ID (unique build ID bitstring)\n");
        fprintf(stderr, "[.]     Build ID: 69b29ab4702120e85902e955001a955a9a4d5246\n");
        fprintf(stderr, "[.]\n");
        fprintf(stderr, "[.] Run %s with `--build-id 69b29ab4702120e85902e955001a955a9a4d5246`.\n",
                __progname);
        return EXIT_FAILURE;
    }
    if (!offset) {
        fprintf(stderr, "[!] Offset to `command_to_handler` needs to be provided. Use `--offset`.\n");
        fprintf(stderr, "[.]\n");
        fprintf(stderr, "[.] Use `readelf -s` to find it.\n");
        fprintf(stderr, "[.] You should get something like this:\n");
        fprintf(stderr, "[.]\n");
        fprintf(stderr, "[.]     47: 0000000000202080   256 OBJECT  LOCAL  DEFAULT   25 command_to_handler\n");
        fprintf(stderr, "[.]\n");
        fprintf(stderr, "[.] Run %s with `--offset 0000000000202080`.\n",
                __progname);
        return EXIT_FAILURE;
    }

    void *base;                 /* base address */
    int type;                   /* ET_EXEC or ET_DYN */
    if (0 ||
        patch_attach(pid) == -1 ||
        patch_base_address(pid, &base) == -1 ||
        patch_sanity_checks(pid, base, &type, build_id) == -1 ||
        patch_doit(pid, base, type, offset) == -1 ||
        /* Detach is done automatically when we exit */
        0) return EXIT_FAILURE;
    return EXIT_SUCCESS;
}
